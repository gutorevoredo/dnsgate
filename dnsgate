#!/usr/bin/env python3
# tab-width:4
# pylint: disable=missing-docstring

# PUBLIC DOMAIN
# http://github.com/jkeogh/dnsgate

import copy
import time
import sys
import os
import requests
import argparse
import tldextract
from urllib.parse import urlparse

CONFIG_DIRECTORY = '/etc/dnsgate'
CACHE_DIRECTORY = CONFIG_DIRECTORY + '/cache'
DEFAULT_BLACKLIST = CONFIG_DIRECTORY + '/blacklist'
DEFAULT_WHITELIST = CONFIG_DIRECTORY + '/whitelist'
DEFAULT_OUTPUT_FILE = CONFIG_DIRECTORY + '/generated_blacklist.conf'
DEFAULT_BLACKLIST_SOURCES = ['http://winhelp2002.mvps.org/hosts.txt',\
                             'http://someonewhocares.org/hosts/hosts', DEFAULT_BLACKLIST]
DEFAULT_WHITELIST_SOURCES = [DEFAULT_WHITELIST]

class DefaultHelpParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write('error: %s\n\n' % message)
        self.print_help()
        sys.exit(2)
    def _get_option_tuples(self, option_string):    #https://bugs.python.org/issue14910
        return []

# http://stackoverflow.com/questions/3853722/python-argparse-how-to-insert-newline-in-the-help-text
class SmartFormatter(argparse.HelpFormatter):
    def _split_lines(self, text, width):
        # this is the RawTextHelpFormatter._split_lines
        if text.startswith('R|'):
            return text[2:].splitlines()
        return argparse.HelpFormatter._split_lines(self, text, width)

# pylint: disable=invalid-name
parser = DefaultHelpParser(formatter_class=SmartFormatter, add_help=True)
format_help = 'R|generate /etc/dnsmasq.conf (default) or /etc/hosts format output file\n\n'
output_help = 'R|output file (defaults to ' + DEFAULT_OUTPUT_FILE + '\nwith --format=dnsmasq and stdout with --format=hosts)\n\n'
force_help = 'R|overwrite existing output file\n\n'
blacklist_help = 'R|blacklist(s) defaults to:\n    ' + '\n    '.join(DEFAULT_BLACKLIST_SOURCES[0:2]) + '\n    '\
                        + DEFAULT_BLACKLIST_SOURCES[2].replace(os.path.expanduser('~'), '~') + '\n\n'
whitelist_help = 'R|whitelists(s) defaults to:\n    ' + DEFAULT_WHITELIST.replace(os.path.expanduser('~'), '~') + '\n\n'
block_at_tld_help = 'R|remove subdomains (see --whitelist)\nexample:\n    analytics.google.com -> google.com\n'\
                        + 'not enabled by default. Useful for dnsmasq if you are willing\n'\
                        + 'to maintain a --whitelist file for inadvertently blocked\n'\
                        + 'domains. This causes ad-serving domains to be blocked at their\n'\
                        + 'TLD. Without this option, the domain owner can change the\n'\
                        + 'subdomain until the --url lists are updated. It does not make\n'\
                        + 'sense to use this flag if you are generating a /etc/hosts\n'\
                        + 'format file since the effect would be to block google.com and\n'\
                        + 'not *.google.com\n\n'
verbose_help = 'R|print additional debugging information to stderr\n\n'
install_help = 'R|print example install and configure information\n\n'
cache_help = 'R|cache --url files as dnsgate_cache_domain_hosts.(timestamp)\n'\
                    + 'to ~/.dnsgate/cache\n\n'
dest_ip_help = 'R|IP to redirect blocked connections to. Defaults to 127.0.0.1\n\n'
restart_dnsmasq_help = 'R|Restart dnsmasq service. Ignored if --format=hosts\n\n'
blacklist_append_help = 'R|Add domains(s) to ' + DEFAULT_BLACKLIST + ' \n\n'
whitelist_append_help = 'R|Add domains(s) to ' + DEFAULT_WHITELIST + ' \n\n'
# ignore 'Exactly one space required after comma'
# pylint: disable=C0324
parser.add_argument("--format",       help=format_help,    type=str, nargs=1, choices=['dnsmasq', 'hosts'],\
                                                                                default=['dnsmasq'])
parser.add_argument("--blacklist",    help=blacklist_help, type=str, nargs='*', default=DEFAULT_BLACKLIST_SOURCES)
parser.add_argument("--whitelist",    help=whitelist_help, type=str, nargs='*', default=DEFAULT_WHITELIST_SOURCES)
parser.add_argument("--blacklist-append", help=blacklist_append_help, type=str, nargs='*')
parser.add_argument("--whitelist-append", help=whitelist_append_help, type=str, nargs='*')
parser.add_argument("--output",       help=output_help,    type=str)
parser.add_argument("--dest-ip",      help=dest_ip_help,   type=str,            default='127.0.0.1')
parser.add_argument("--block-at-tld", help=block_at_tld_help, action="store_true", default=False)
parser.add_argument("--verbose",      help=verbose_help,   action="store_true", default=False)
parser.add_argument("--install-help", help=install_help,   action="store_true", default=False)
parser.add_argument("--cache",    help=cache_help, action="store_true", default=False)
parser.add_argument("--force",        help=force_help,     action="store_true", default=False)
parser.add_argument("--restart-dnsmasq", help=restart_dnsmasq_help, action="store_true", default=False)
# pylint: enable=C0324
# pylint: enable=invalid-name

def show_install_help():
    if CMD_ARGS.format == ['dnsmasq']:
        eprint('    $ dnsgate --format=dnsmasq --output=dnsgate_output')
        eprint('    $ cp -vi dnsgate_output /etc/')
        eprint('    $ cp -vi /etc/dnsmasq.conf /etc/dnsmasq.conf.bak')
        eprint('    $ echo \"conf-file=/etc/dnsgate_output\" >> /etc/dnsmasq.conf')
        eprint('    $ /etc/init.d/dnsmasq restart')
    elif CMD_ARGS.format == ['hosts']:
        eprint('    $ dnsgate --format=hosts --output=dnsgate_output')
        eprint("    $ cp -vi /etc/hosts /etc/hosts.bak")
        eprint("    $ cat dnsgate_output >> /etc/hosts")
        eprint("    NOTE: \"cp /etc/hosts.bak /etc/hosts\" before doing this a second time.")
    eprint("\nSee --help and --verbose for more information.")
    quit(0)

def vprint(*args, **kwargs):
    if CMD_ARGS.verbose:
        caller = sys._getframe(1).f_code.co_name
        print(str("%.5f" % time.time()), os.getpid(), '{0: <15}'.format(caller+'()'), *args, file=sys.stderr, **kwargs)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def restart_dnsmasq():
    if os.path.lexists('/etc/init.d/dnsmasq'):
        ret = os.system('/etc/init.d/dnsmasq restart')
    else:
        ret = os.system('systemctl restart dnsmasq')    # untested
    return ret

def extract_domains_from_bytes_list(domain_bytes):
    domains = set()
    for line in domain_bytes:
        line = line.decode('UTF-8')
        line = line.replace('\t', ' ')
        line = " ".join(line.split())           # collapse whitespace
        line = line.strip()
        if len(line) == 0:                      # skip empty lines
            continue
        if not line.startswith('#'):            # remove comments
            line = line.split(' ')[1]           # get DNS name (the url's are in hosts 0.0.0.0 dom.com format)
            # pylint: disable=bad-builtin
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading and trailing .
            # pylint: enable=bad-builtin
            domains.add(line)
    return domains

def get_url(url):
    if url.startswith('http://') or url.startswith('https://'):
        vprint("GET:", url)
        user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:24.0) Gecko/20100101 Firefox/24.0'
        try:
            raw_hosts_file_lines = requests.get(url, headers={'User-Agent': user_agent}, allow_redirects=True,\
                                   stream=False, timeout=15.500).content.split(b'\n')
        except Exception as e:
            eprint("Exception:", e)
            raise e
        if CMD_ARGS.cache:
            domain = urlparse(url).netloc
            output_file = CACHE_DIRECTORY + '/' + 'dnsgate_cache_' + domain + '_hosts.' + str(time.time())
            if not os.path.isdir(CACHE_DIRECTORY):
                os.makedirs(CACHE_DIRECTORY)
            with open(output_file, 'wb') as fh:
                for line in raw_hosts_file_lines:
                    fh.write(line + b'\n')
        domains = extract_domains_from_bytes_list(raw_hosts_file_lines)
    else:
        eprint("unknown url scheme:", url)
        os._exit(1)

    vprint("domains in", url, ":", len(domains))
    return domains

def group_by_tld(domains):
    sorted_output = []
    reversed_domains = []
    for domain in domains:
        rev_domain = domain.split('.')
        rev_domain.reverse()
        reversed_domains.append(rev_domain)
    reversed_domains.sort() #sorting a list of lists by the tld
    for rev_domain in reversed_domains:
        rev_domain.reverse()
        sorted_output.append('.'.join(rev_domain))
    return sorted_output

def read_file(file):
    if os.path.isfile(file):
        with open(file, 'r') as fh:
            file_bytes = fh.read()
        return file_bytes
    else:
        raise FileNotFoundError(file + ' does not exist.')

def domain_extract(domain):
    dom = no_cache_extract(domain)  #prevent tldextract cache update error when run as a normal user
    return dom

def block_at_tld(domains):
    domains_stripped = set()
    for line in domains:
        line = domain_extract(line)             # get tld
        line = line.domain + '.' + line.suffix
        domains_stripped.add(line)
    return domains_stripped

def write_unique_line(line, file):
    with open(file, 'r+') as fh:
        if line not in fh:
            fh.write(line)

def read_list_of_domains(file):
    domains = set([])
    file = os.path.abspath(file)
    try:
        lines = read_file(file).splitlines()
    except Exception as e:
        eprint(e)
    else:
        for line in lines:
            line = line.strip()
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading and trailing .
            if len(line) > 0:
                domains.add(line)
    return domains

def main():
    if CMD_ARGS.install_help:
        show_install_help()

    if not CMD_ARGS.output and CMD_ARGS.format == ['hosts']:
        output_file = '/dev/stdout'
    elif not CMD_ARGS.output and CMD_ARGS.format == ['dnsmasq']:
        output_file = DEFAULT_OUTPUT_FILE
    else:
        output_file = os.path.abspath(CMD_ARGS.output)

    if os.path.isfile(output_file) and CMD_ARGS.output != '/dev/stdout':
        if not CMD_ARGS.force:
            eprint("File '%s' exists. Refusing to overwrite. Use --force. Exiting." % output_file)
            quit(1)

#   idn='☃.net'
    if CMD_ARGS.whitelist_append:
        for idn in CMD_ARGS.whitelist_append:
            hostname = idn.encode('idna').decode('ascii')
            vprint("appending hostname:", hostname, "to", DEFAULT_WHITELIST)
            line = hostname + '\n'
            write_unique_line(line, DEFAULT_WHITELIST)

    if CMD_ARGS.blacklist_append:
        for idn in CMD_ARGS.blacklist_append:
            hostname = idn.encode('idna').decode('ascii')
            vprint("appending hostname:", hostname, "to", DEFAULT_BLACKLIST)
            line = hostname + '\n'
            write_unique_line(line, DEFAULT_BLACKLIST)

    domains_whitelist = set()
    for whitelist in CMD_ARGS.whitelist:
        whitelist_file = os.path.abspath(whitelist)
        domains_whitelist = domains_whitelist|read_list_of_domains(whitelist_file)

    domains_combined_orig = set()   # domains from all sources, combined

    for blacklist in CMD_ARGS.blacklist:
        if blacklist.startswith('http'):
            try:
                domains = get_url(blacklist)
                domains_combined_orig = domains_combined_orig|domains # union
                vprint("blacklist:", blacklist, "len(domains_combined_orig):", len(domains_combined_orig))

            except Exception as e:
                eprint("Exception on blacklist url:", blacklist)
                eprint(e)

        else:
            domains = read_list_of_domains(blacklist)
            if domains:
                domains_combined_orig = domains_combined_orig|domains # union

    domains_combined = copy.deepcopy(domains_combined_orig)

    if CMD_ARGS.block_at_tld:
        domains_combined = block_at_tld(domains_combined)

    # re-add subdomains of whitelisted domains
    domains_combined = domains_combined - domains_whitelist  # remove exact whitelist matches

    #re-add subdomains that are not explicitly whitelisted or already blocked by another rule
    for orig_domain in domains_combined_orig:
        if orig_domain not in domains_whitelist:
            if orig_domain not in domains_combined:
                orig_domain_tldextract = domain_extract(orig_domain)
                orig_domain_tld = orig_domain_tldextract.domain + '.' + orig_domain_tldextract.suffix
                if orig_domain_tld not in domains_combined:
                    vprint("re-adding:", orig_domain)
                    domains_combined.add(orig_domain)

    domains_combined = group_by_tld(domains_combined)

    if CMD_ARGS.format == ['hosts']:
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                hosts_line = CMD_ARGS.dest_ip + ' ' + domain + '\n'
                fh.write(hosts_line)

    elif CMD_ARGS.format == ['dnsmasq']:
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                dnsmasq_line = 'address=/.' + domain + '/' + CMD_ARGS.dest_ip + '\n'
                fh.write(dnsmasq_line)

if __name__ == '__main__':
    no_cache_extract = tldextract.TLDExtract(cache_file=False)
    CMD_ARGS = parser.parse_args()
    main()
    vprint("Exiting without error.")
    if CMD_ARGS.restart_dnsmasq:
        if CMD_ARGS.format != ['hosts']:
            restart_dnsmasq()
    quit(0)
