#!/usr/bin/env python3
# tab-width:4
# pylint: disable=missing-docstring

# PUBLIC DOMAIN
# http://github.com/jkeogh/dnsgate

import click
import copy
import time
import sys
import os
import requests
import tldextract
from urllib.parse import urlparse
from shutil import copyfileobj

CONFIG_DIRECTORY = '/etc/dnsgate'
CACHE_DIRECTORY = CONFIG_DIRECTORY + '/cache'
DEFAULT_BLACKLIST = CONFIG_DIRECTORY + '/blacklist'
DEFAULT_WHITELIST = CONFIG_DIRECTORY + '/whitelist'
DEFAULT_OUTPUT_FILE = CONFIG_DIRECTORY + '/generated_blacklist'
DEFAULT_BLACKLIST_SOURCES = ['http://winhelp2002.mvps.org/hosts.txt',\
                             'http://someonewhocares.org/hosts/hosts', DEFAULT_BLACKLIST]
DEFAULT_WHITELIST_SOURCES = [DEFAULT_WHITELIST]

# pylint: disable=invalid-name

output_format_help = 'R|dnsmasq (default) or /etc/hosts format output\n\n'
output_help = 'R|output file (defaults to ' + DEFAULT_OUTPUT_FILE + '\nwith --format=dnsmasq and stdout with --format=hosts)\n\n'
noclobber_help = 'R|do not overwrite existing output file\n\n'
backup_help = 'R|backup output file before overwriting with --noclobber\n\n'
blacklist_help = 'R|blacklist(s) defaults to:\n    ' + '\n    '.join(DEFAULT_BLACKLIST_SOURCES[0:2]) + '\n    '\
                        + DEFAULT_BLACKLIST_SOURCES[2].replace(os.path.expanduser('~'), '~') + '\n\n'
whitelist_help = 'R|whitelists(s) defaults to:\n    ' + DEFAULT_WHITELIST.replace(os.path.expanduser('~'), '~') + '\n\n'
block_at_tld_help = 'R|remove subdomains (see --whitelist)\nexample:\n    analytics.google.com -> google.com\n'\
                        + 'not enabled by default. Useful for dnsmasq if you are willing\n'\
                        + 'to maintain a --whitelist file for inadvertently blocked\n'\
                        + 'domains. This causes ad-serving domains to be blocked at their\n'\
                        + 'TLD. Without this option, the domain owner can change the\n'\
                        + 'subdomain until the --url lists are updated. It does not make\n'\
                        + 'sense to use this flag if you are generating a /etc/hosts\n'\
                        + 'format file since the effect would be to block google.com and\n'\
                        + 'not *.google.com\n\n'
debug_help = 'R|print additional debugging information to stderr\n\n'
verbose_help = 'R|print additional config information to stderr\n\n'
cache_help = 'R|cache --url files as dnsgate_cache_domain_hosts.(timestamp)\n'\
                    + 'to ~/.dnsgate/cache\n\n'
dest_ip_help = 'R|IP to redirect blocked connections to. Defaults to 127.0.0.1\n\n'
restart_dnsmasq_help = 'R|Restart dnsmasq service (defaults to True). Ignored if --format=hosts\n\n'
blacklist_append_help = 'R|Add domains(s) to ' + DEFAULT_BLACKLIST + ' \n\n'
whitelist_append_help = 'R|Add domains(s) to ' + DEFAULT_WHITELIST + ' \n\n'

# ignore 'Exactly one space required after comma'
# pylint: disable=C0324
# pylint: enable=C0324
# pylint: enable=invalid-name


def dprint(*args, **kwargs):
    if click_debug:
        caller = sys._getframe(1).f_code.co_name
        print(str("%.5f" % time.time()), os.getpid(), '{0: <15}'.format(caller+'()'), *args, file=sys.stderr, **kwargs)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def restart_dnsmasq():
    if os.path.lexists('/etc/init.d/dnsmasq'):
        ret = os.system('/etc/init.d/dnsmasq restart')
    else:
        ret = os.system('systemctl restart dnsmasq')    # untested
    return ret

def extract_domains_from_bytes_list(domain_bytes):
    domains = set()
    for line in domain_bytes:
        line = line.decode('UTF-8')
        line = line.replace('\t', ' ')
        line = " ".join(line.split())           # collapse whitespace
        line = line.strip()
        if len(line) == 0:                      # skip empty lines
            continue
        if not line.startswith('#'):            # remove comments
            line = line.split(' ')[1]           # get DNS name (the url's are in hosts 0.0.0.0 dom.com format)
            # pylint: disable=bad-builtin
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading and trailing .
            # pylint: enable=bad-builtin
            domains.add(line)
    return domains

def get_url(url, cache=False):
    if url.startswith('http://') or url.startswith('https://'):
        dprint("GET:", url)
        user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:24.0) Gecko/20100101 Firefox/24.0'
        try:
            raw_hosts_file_lines = requests.get(url, headers={'User-Agent': user_agent}, allow_redirects=True,\
                                   stream=False, timeout=15.500).content.split(b'\n')
        except Exception as e:
            eprint("Exception:", e)
            raise e
        if cache:
            domain = urlparse(url).netloc
            output_file = CACHE_DIRECTORY + '/' + 'dnsgate_cache_' + domain + '_hosts.' + str(time.time())
            if not os.path.isdir(CACHE_DIRECTORY):
                os.makedirs(CACHE_DIRECTORY)
            with open(output_file, 'wb') as fh:
                for line in raw_hosts_file_lines:
                    fh.write(line + b'\n')
        domains = extract_domains_from_bytes_list(raw_hosts_file_lines)
    else:
        eprint("unknown url scheme:", url)
        os._exit(1)

    dprint("domains in", url, ":", len(domains))
    return domains

def group_by_tld(domains):
    sorted_output = []
    reversed_domains = []
    for domain in domains:
        rev_domain = domain.split('.')
        rev_domain.reverse()
        reversed_domains.append(rev_domain)
    reversed_domains.sort() #sorting a list of lists by the tld
    for rev_domain in reversed_domains:
        rev_domain.reverse()
        sorted_output.append('.'.join(rev_domain))
    return sorted_output

def read_file(file):
    if os.path.isfile(file):
        with open(file, 'r') as fh:
            file_bytes = fh.read()
        return file_bytes
    else:
        raise FileNotFoundError(file + ' does not exist.')

def domain_extract(domain):
    dom = no_cache_extract(domain)  #prevent tldextract cache update error when run as a normal user
    return dom

def block_at_tld(domains):
    domains_stripped = set()
    for line in domains:
        line = domain_extract(line)             # get tld
        line = line.domain + '.' + line.suffix
        domains_stripped.add(line)
    return domains_stripped

def write_unique_line(line, file):
    with open(file, 'r+') as fh:
        if line not in fh:
            fh.write(line)

def read_list_of_domains(file):
    domains = set([])
    file = os.path.abspath(file)
    try:
        lines = read_file(file).splitlines()
    except Exception as e:
        eprint(e)
    else:
        for line in lines:
            line = line.strip()
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading and trailing .
            if len(line) > 0:
                domains.add(line)
    return domains

def backup_file_if_exists(file):
    timestamp = str(time.time())
    dest_file = file + '.bak.' + timestamp
    try:
        with open(file, 'r') as sf:
            with open(dest_file, 'x') as df:
                copyfileobj(sf, df)
    except FileNotFoundError:
        pass    # skip backup is file does not exist
            
def validate_domain_list(domains):
    for hostname in domains:
        hostname = hostname.encode('idna').decode('ascii')
        #print(hostname)

CONTEXT_SETTINGS = dict(help_option_names=['--chelp'])
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--debug',            required=False, is_flag=True,  help=debug_help)
@click.option('--cache',            required=False, is_flag=True,  help=cache_help)
@click.option('--noclobber',        required=False, is_flag=True,  help=noclobber_help)
@click.option('--block-at-tld',     required=False, is_flag=True,  help=block_at_tld_help)
@click.option('--backup',           required=False, is_flag=True,  help=backup_help)
@click.option('--restart-dnsmasq',  required=False, is_flag=True,  help=restart_dnsmasq_help)
@click.option('--output-format',    required=False, is_flag=False, help=output_format_help,    type=click.Choice(['dnsmasq', 'hosts']), default='dnsmasq')
@click.option('--output',           required=False, is_flag=False, help=output_help,           default=DEFAULT_OUTPUT_FILE)
@click.option('--blacklist-append', required=False, is_flag=False, help=blacklist_append_help, type=list)
@click.option('--whitelist-append', required=False, is_flag=False, help=whitelist_append_help, type=list)
@click.option('--blacklist',        required=False, is_flag=False, help=blacklist_help, default=DEFAULT_BLACKLIST_SOURCES)
@click.option('--whitelist',        required=False, is_flag=False, help=whitelist_help, default=DEFAULT_WHITELIST_SOURCES)
@click.option('--dest-ip',          required=False, is_flag=False, help=dest_ip_help, default='127.0.0.1')
def main(output, output_format, debug, noclobber, block_at_tld, backup, whitelist_append, blacklist_append, blacklist, whitelist, restart_dnsmasq, dest_ip, cache):
    global click_debug
    click_debug = debug

    if output == '-' or output == '/dev/stdout':
        output_file = '/dev/stdout'
    else:
        dprint("using non standard output_file")
        output_file = os.path.abspath(output)

    if os.path.isfile(output_file) and output_file != '/dev/stdout':
        if noclobber:
            eprint("File '%s' exists. Refusing to overwrite because --noclobber was used. Exiting." % output_file)
            quit(1)

    dprint('output_file:', output_file)

#   idn='â˜ƒ.net'
    if whitelist_append:
        for idn in whitelist_append:
            hostname = idn.encode('idna').decode('ascii')
            dprint("appending hostname:", hostname, "to", DEFAULT_WHITELIST)
            line = hostname + '\n'
            write_unique_line(line, DEFAULT_WHITELIST)

    if blacklist_append:
        for idn in blacklist_append:
            hostname = idn.encode('idna').decode('ascii')
            dprint("appending hostname:", hostname, "to", DEFAULT_BLACKLIST)
            line = hostname + '\n'
            write_unique_line(line, DEFAULT_BLACKLIST)

    domains_whitelist = set()
    for whitelist in whitelist:
        whitelist_file = os.path.abspath(whitelist)
        domains_whitelist = domains_whitelist|read_list_of_domains(whitelist_file)

    domains_combined_orig = set()   # domains from all sources, combined

    for blacklist in blacklist:
        if blacklist.startswith('http'):
            try:
                domains = get_url(blacklist, cache)
                domains_combined_orig = domains_combined_orig|domains # union
                dprint("blacklist:", blacklist, "len(domains_combined_orig):", len(domains_combined_orig))

            except Exception as e:
                eprint("Exception on blacklist url:", blacklist)
                eprint(e)

        else:
            domains = read_list_of_domains(blacklist)
            if domains:
                domains_combined_orig = domains_combined_orig|domains # union

    validate_domain_list(domains_combined_orig)

    domains_combined = copy.deepcopy(domains_combined_orig)

    if block_at_tld:
        domains_combined = block_at_tld(domains_combined)

    # re-add subdomains of whitelisted domains
    domains_combined = domains_combined - domains_whitelist  # remove exact whitelist matches

    #re-add subdomains that are not explicitly whitelisted or already blocked by another rule
    for orig_domain in domains_combined_orig:
        if orig_domain not in domains_whitelist:
            if orig_domain not in domains_combined:
                orig_domain_tldextract = domain_extract(orig_domain)
                orig_domain_tld = orig_domain_tldextract.domain + '.' + orig_domain_tldextract.suffix
                if orig_domain_tld not in domains_combined:
                    dprint("re-adding:", orig_domain)
                    domains_combined.add(orig_domain)

    domains_combined = group_by_tld(domains_combined)

    if backup:
        backup_file_if_exists(output_file)

    if output_format == 'hosts':
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                hosts_line = dest_ip + ' ' + domain + '\n'
                fh.write(hosts_line)

    elif output_format == 'dnsmasq':
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                dnsmasq_line = 'address=/.' + domain + '/' + dest_ip + '\n'
                fh.write(dnsmasq_line)
    else:
        print("unknown output format:", output_format)
        quit(1)

    if restart_dnsmasq:
        if output_format != 'hosts':
            restart_dnsmasq()


if __name__ == '__main__':
    no_cache_extract = tldextract.TLDExtract(cache_file=False)
    main()
    dprint("Exiting without error.")
    quit(0)
