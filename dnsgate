#!/usr/bin/env python3
# tab-width:4
# pylint: disable=missing-docstring

# PUBLIC DOMAIN
# http://github.com/jkeogh/dnsgate

import click
import copy
import time
import sys
import os
import shutil
import inspect
import requests
import tldextract
from urllib.parse import urlparse
from shutil import copyfileobj

CONFIG_DIRECTORY = '/etc/dnsgate'
CACHE_DIRECTORY = CONFIG_DIRECTORY + '/cache'
DEFAULT_BLACKLIST = CONFIG_DIRECTORY + '/blacklist'
DEFAULT_WHITELIST = CONFIG_DIRECTORY + '/whitelist'
DEFAULT_OUTPUT_FILE = CONFIG_DIRECTORY + '/generated_blacklist'
DEFAULT_BLACKLIST_SOURCES = ['http://winhelp2002.mvps.org/hosts.txt',\
                             'http://someonewhocares.org/hosts/hosts', DEFAULT_BLACKLIST]
DEFAULT_WHITELIST_SOURCES = [DEFAULT_WHITELIST]

def dprint(*args, **kwargs):
    if click_debug:
        caller = sys._getframe(1).f_code.co_name
        print(str("%.5f" % time.time()), os.getpid(), '{0: <15}'.format(caller+'()'), *args, file=sys.stderr, **kwargs)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def restart_dnsmasq_service():
    if os.path.lexists('/etc/init.d/dnsmasq'):
        ret = os.system('/etc/init.d/dnsmasq restart')
    else:
        ret = os.system('systemctl restart dnsmasq')    # untested
    return ret

def extract_domains_from_bytes_list(domain_bytes):
    domains = set()
    for line in domain_bytes:
        line = line.decode('UTF-8')
        line = line.replace('\t', ' ')
        line = " ".join(line.split())           # collapse whitespace
        line = line.strip()
        if len(line) == 0:                      # skip empty lines
            continue
        if not line.startswith('#'):            # remove comments
            line = line.split(' ')[1]           # get DNS name (the url's are in hosts 0.0.0.0 dom.com format)
            # pylint: disable=bad-builtin
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading and trailing .
            # pylint: enable=bad-builtin
            domains.add(line)
    return domains

def get_url(url, cache=False):
    if url.startswith('http://') or url.startswith('https://'):
        dprint("GET:", url)
        user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:24.0) Gecko/20100101 Firefox/24.0'
        try:
            raw_hosts_file_lines = requests.get(url, headers={'User-Agent': user_agent}, allow_redirects=True,\
                                   stream=False, timeout=15.500).content.split(b'\n')
        except Exception as e:
            eprint("Exception:", e)
            raise e
        if cache:
            domain = urlparse(url).netloc
            output_file = CACHE_DIRECTORY + '/' + 'dnsgate_cache_' + domain + '_hosts.' + str(time.time())
            if not os.path.isdir(CACHE_DIRECTORY):
                os.makedirs(CACHE_DIRECTORY)
            with open(output_file, 'wb') as fh:
                for line in raw_hosts_file_lines:
                    fh.write(line + b'\n')
        domains = extract_domains_from_bytes_list(raw_hosts_file_lines)
    else:
        eprint("unknown url scheme:", url)
        os._exit(1)

    dprint("domains in", url, ":", len(domains))
    return domains

def group_by_tld(domains):
    sorted_output = []
    reversed_domains = []
    for domain in domains:
        rev_domain = domain.split('.')
        rev_domain.reverse()
        reversed_domains.append(rev_domain)
    reversed_domains.sort() #sorting a list of lists by the tld
    for rev_domain in reversed_domains:
        rev_domain.reverse()
        sorted_output.append('.'.join(rev_domain))
    return sorted_output

def read_file(file):
    if os.path.isfile(file):
        with open(file, 'r') as fh:
            file_bytes = fh.read()
        return file_bytes
    else:
        raise FileNotFoundError(file + ' does not exist.')

def domain_extract(domain):
    dom = no_cache_extract(domain)  #prevent tldextract cache update error when run as a normal user
    return dom

def strip_to_tld(domains):
    '''This causes ad-serving domains to be blocked at their TLD. Otherwise the subdomain can be changed until the --url lists are updated. It does not make sense to use this flag if you are generating a /etc/hosts format file since the effect would be to block google.com and not *.google.com.'''
    domains_stripped = set()
    for line in domains:
        line = domain_extract(line)             # get tld
        line = line.domain + '.' + line.suffix
        domains_stripped.add(line)
    return domains_stripped

def write_unique_line(line, file):
    with open(file, 'r+') as fh:
        if line not in fh:
            fh.write(line)

def read_list_of_domains(file):
    domains = set([])
    file = os.path.abspath(file)
    try:
        lines = read_file(file).splitlines()
    except Exception as e:
        eprint(e)
    else:
        for line in lines:
            line = line.strip()
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading and trailing .
            if len(line) > 0:
                domains.add(line)
    return domains

def backup_file_if_exists(file):
    timestamp = str(time.time())
    dest_file = file + '.bak.' + timestamp
    try:
        with open(file, 'r') as sf:
            with open(dest_file, 'x') as df:
                copyfileobj(sf, df)
    except FileNotFoundError:
        pass    # skip backup is file does not exist
            
def validate_domain_list(domains):
    for hostname in domains:
        hostname = hostname.encode('idna').decode('ascii')
        #print(hostname)

# pylint: disable=invalid-name
output_file_help = '''output file (defaults to ''' + DEFAULT_OUTPUT_FILE + ' with --format=dnsmasq and stdout with --format=hosts)'
noclobber_help = '''do not overwrite existing output file'''
backup_help = '''backup output file before overwriting'''
blacklist_help = '''\b
blacklist(s) defaults to:
''' + '\n'.join(['    {0}'.format(i) for i in DEFAULT_BLACKLIST_SOURCES])

whitelist_help = '''\b
whitelists(s) defaults to:''' + DEFAULT_WHITELIST.replace(os.path.expanduser('~'), '~') 
block_at_tld_help = '''
\b
strips subdomains, for example:
    analytics.google.com -> google.com
    Useful for dnsmasq if you are willing to maintain a --whitelist file for inadvertently blocked domains.'''
debug_help = '''print debugging information to stderr'''
show_config_help = '''print config information to stderr'''
cache_help = '''cache --url files as dnsgate_cache_domain_hosts.(timestamp) to ~/.dnsgate/cache'''
dest_ip_help = '''IP to redirect blocked connections to (defaults to 127.0.0.1)'''
restart_dnsmasq_help = '''Restart dnsmasq service (defaults to True, ignored if --format=hosts)'''
blacklist_append_help = '''Add domain to ''' + DEFAULT_BLACKLIST
whitelist_append_help = '''Add domain to ''' + DEFAULT_WHITELIST
# pylint: enable=invalid-name

CONTEXT_SETTINGS = dict(help_option_names=['--help'], terminal_width=shutil.get_terminal_size((80, 20)).columns) #https://github.com/mitsuhiko/click/issues/441
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--output-format',    required=False, is_flag=False, type=click.Choice(['dnsmasq', 'hosts']), default='dnsmasq')
@click.option('--show-config',      required=False, is_flag=True,  help=show_config_help)
@click.option('--debug',            required=False, is_flag=True,  help=debug_help)
@click.option('--cache',            required=False, is_flag=True,  help=cache_help)
@click.option('--noclobber',        required=False, is_flag=True,  help=noclobber_help)
@click.option('--block-at-tld',     required=False, is_flag=True,  help=block_at_tld_help)
@click.option('--backup',           required=False, is_flag=True,  help=backup_help)
@click.option('--restart-dnsmasq',  required=False, is_flag=True,  help=restart_dnsmasq_help,  default=True)
@click.option('--output-file',      required=False, is_flag=False, help=output_file_help,      default=DEFAULT_OUTPUT_FILE)
@click.option('--blacklist-append', required=False, is_flag=False, help=blacklist_append_help, type=str)
@click.option('--whitelist-append', required=False, is_flag=False, help=whitelist_append_help, type=str)
@click.option('--blacklist',        required=False, is_flag=False, help=blacklist_help, default=DEFAULT_BLACKLIST_SOURCES)
@click.option('--whitelist',        required=False, is_flag=False, help=whitelist_help, default=DEFAULT_WHITELIST_SOURCES)
@click.option('--dest-ip',          required=False, is_flag=False, help=dest_ip_help, default='127.0.0.1')
#@click.pass_context
def main(output_file, output_format, show_config, debug, cache, noclobber, block_at_tld, backup, whitelist_append, blacklist_append, blacklist, whitelist, restart_dnsmasq, dest_ip):

    if show_config:
        print("output_file:", output_file)
        print("output_format:", output_format)
        print("debug:", debug)
        print("show_config:", show_config)
        print("cache:", cache)
        print("noclobber:", noclobber)
        print("block_at_tld:", block_at_tld)
        print("backup:", backup)
        print("whitelist_append:", whitelist_append)
        print("blacklist_append:", blacklist_append)
        print("blacklist:", blacklist)
        print("whitelist:", whitelist)
        print("restart_dnsmasq:", restart_dnsmasq)
        print("dest_ip:", dest_ip)
        
    global click_debug
    click_debug = debug

    if output_file == '-' or output_file == '/dev/stdout':
        output_file = '/dev/stdout'
    else:
        dprint("using non standard output_file")
        output_file = os.path.abspath(output_file)

    if os.path.isfile(output_file) and output_file != '/dev/stdout':
        if noclobber:
            eprint("File '%s' exists. Refusing to overwrite because --noclobber was used. Exiting." % output_file)
            quit(1)

    dprint('output_file:', output_file)

#   idn='â˜ƒ.net'
    if whitelist_append:
        idn = whitelist_append
        dprint("idn:", idn)
        hostname = idn.encode('idna').decode('ascii')
        dprint("appending hostname:", hostname, "to", DEFAULT_WHITELIST)
        line = hostname + '\n'
        write_unique_line(line, DEFAULT_WHITELIST)

    if blacklist_append:
        idn = blacklist_append
        hostname = idn.encode('idna').decode('ascii')
        dprint("appending hostname:", hostname, "to", DEFAULT_BLACKLIST)
        line = hostname + '\n'
        write_unique_line(line, DEFAULT_BLACKLIST)

    domains_whitelist = set()
    for whitelist in whitelist:
        whitelist_file = os.path.abspath(whitelist)
        domains_whitelist = domains_whitelist|read_list_of_domains(whitelist_file)

    domains_combined_orig = set()   # domains from all sources, combined

    for blacklist in blacklist:
        if blacklist.startswith('http'):
            try:
                domains = get_url(blacklist, cache)
                domains_combined_orig = domains_combined_orig|domains # union
                dprint("blacklist:", blacklist, "len(domains_combined_orig):", len(domains_combined_orig))

            except Exception as e:
                eprint("Exception on blacklist url:", blacklist)
                eprint(e)

        else:
            domains = read_list_of_domains(blacklist)
            if domains:
                domains_combined_orig = domains_combined_orig|domains # union

    validate_domain_list(domains_combined_orig)

    domains_combined = copy.deepcopy(domains_combined_orig)

    if block_at_tld:
        domains_combined = strip_to_tld(domains_combined)

    # re-add subdomains of whitelisted domains
    domains_combined = domains_combined - domains_whitelist  # remove exact whitelist matches

    #re-add subdomains that are not explicitly whitelisted or already blocked by another rule
    for orig_domain in domains_combined_orig:
        if orig_domain not in domains_whitelist:
            if orig_domain not in domains_combined:
                orig_domain_tldextract = domain_extract(orig_domain)
                orig_domain_tld = orig_domain_tldextract.domain + '.' + orig_domain_tldextract.suffix
                if orig_domain_tld not in domains_combined:
                    dprint("re-adding:", orig_domain)
                    domains_combined.add(orig_domain)

    domains_combined = group_by_tld(domains_combined)

    if backup:
        backup_file_if_exists(output_file)

    os.mkdir(CONFIG_DIRECTORY)

    if output_format == 'hosts':
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                hosts_line = dest_ip + ' ' + domain + '\n'
                fh.write(hosts_line)

    elif output_format == 'dnsmasq':
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                dnsmasq_line = 'address=/.' + domain + '/' + dest_ip + '\n'
                fh.write(dnsmasq_line)
    else:
        print("unknown output format:", output_format)
        quit(1)

    if restart_dnsmasq:
        if output_format != 'hosts':
            restart_dnsmasq_service()


if __name__ == '__main__':
    no_cache_extract = tldextract.TLDExtract(cache_file=False)
    main()
    dprint("Exiting without error.")
    quit(0)
