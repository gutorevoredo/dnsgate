#!/usr/bin/env python3
# tab-width:4
# pylint: disable=missing-docstring

# PUBLIC DOMAIN
# http://github.com/jkeogh/dnsgate

import click
import copy
import time
import sys
import os
import shutil
import inspect
import requests
import tldextract
from urllib.parse import urlparse
from shutil import copyfileobj
from debug_logging import log_prefix, logger, print_traceback, log_levels

CONFIG_DIRECTORY = '/etc/dnsgate'
CACHE_DIRECTORY = CONFIG_DIRECTORY + '/cache'
DEFAULT_BLACKLIST = CONFIG_DIRECTORY + '/blacklist'
DEFAULT_WHITELIST = CONFIG_DIRECTORY + '/whitelist'
DEFAULT_OUTPUT_FILE = CONFIG_DIRECTORY + '/generated_blacklist'
DEFAULT_BLACKLIST_SOURCES = ['http://winhelp2002.mvps.org/hosts.txt',\
                             'http://someonewhocares.org/hosts/hosts', DEFAULT_BLACKLIST]
DEFAULT_WHITELIST_SOURCES = [DEFAULT_WHITELIST]

def dprint(*args, **kwargs):
    if click_debug:
        caller = sys._getframe(1).f_code.co_name
        print(str("%.5f" % time.time()), os.getpid(), '{0: <15}'.format(caller+'()'), *args, file=sys.stderr, **kwargs)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

@log_prefix()
def restart_dnsmasq_service():
    if os.path.lexists('/etc/init.d/dnsmasq'):
        ret = os.system('/etc/init.d/dnsmasq restart')
    else:
        ret = os.system('systemctl restart dnsmasq')    # untested
    return ret

def remove_comments(line):
    uncommented_line = ''
    for char in line:
        if char != '#':
            uncommented_line += char
        else:
            break
    return uncommented_line    

#@log_prefix()
def extract_domains_from_bytes_list(domain_bytes):
    domains = set()
    for line in domain_bytes:
        line = line.decode('UTF-8')
        line = line.replace('\t', ' ')          # expand tabs
        line = ' '.join(line.split())           # collapse whitespace
        line = line.strip()
        line = remove_comments(line)
        if ' ' in line:                         # hosts format
            line = line.split(' ')[1]           # get DNS name (the url's are in hosts 0.0.0.0 dom.com format)
            # pylint: disable=bad-builtin
            line = '.'.join(list(filter(None, line.split('.'))))    # ignore leading/trailing .
            # pylint: enable=bad-builtin
            domains.add(line)
    return domains

@log_prefix()
def read_list_of_domains(file):
    domains = set([])
    file = os.path.abspath(file)
    try:
        lines = read_file(file).splitlines()
    except Exception as e:
        logger.exception(e)
    else:
        for line in lines:
            line = line.strip()
            line = remove_comments(line)
            line = '.'.join(list(filter(None, line.split('.')))) # ignore leading/trailing . 
            if len(line) > 0:
                domains.add(line)
    return domains

@log_prefix()
def get_url(url, cache=False):
    if url.startswith('http://') or url.startswith('https://'):
        logger.debug("GET: %s", url)
        user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:24.0) Gecko/20100101 Firefox/24.0'
        try:
            raw_hosts_file_lines = requests.get(url, headers={'User-Agent': user_agent}, allow_redirects=True,\
                                   stream=False, timeout=15.500).content.split(b'\n')
        except Exception as e:
            logger.exception(e)
            raise e
        if cache:
            domain = urlparse(url).netloc
            output_file = CACHE_DIRECTORY + '/' + 'dnsgate_cache_' + domain + '_hosts.' + str(time.time())
            if not os.path.isdir(CACHE_DIRECTORY):
                os.makedirs(CACHE_DIRECTORY)
            with open(output_file, 'wb') as fh:
                for line in raw_hosts_file_lines:
                    fh.write(line + b'\n')
        domains = extract_domains_from_bytes_list(raw_hosts_file_lines)
    else:
        eprint("unknown url scheme:", url)
        os._exit(1)

    dprint("domains in", url, ":", len(domains))
    return domains

#@log_prefix()
def group_by_tld(domains):
    sorted_output = []
    reversed_domains = []
    for domain in domains:
        rev_domain = domain.split('.')
        rev_domain.reverse()
        reversed_domains.append(rev_domain)
    reversed_domains.sort() #sorting a list of lists by the tld
    for rev_domain in reversed_domains:
        rev_domain.reverse()
        sorted_output.append('.'.join(rev_domain))
    return sorted_output

@log_prefix()
def read_file(file):
    if os.path.isfile(file):
        with open(file, 'r') as fh:
            file_bytes = fh.read()
        return file_bytes
    else:
        raise FileNotFoundError(file + ' does not exist.')

def domain_extract(domain):
    dom = no_cache_extract(domain)  #prevent tldextract cache update error when run as a normal user
    return dom

def strip_to_tld(domains):
    '''This causes ad-serving domains to be blocked at their TLD. 
    Otherwise the subdomain can be changed until the --url lists are updated.
    It does not make sense to use this flag if you are generating a /etc/hosts
    format file since the effect would be to block google.com and not 
    *.google.com.'''
    domains_stripped = set()
    for line in domains:
        line = domain_extract(line)             # get tld
        line = line.domain + '.' + line.suffix
        domains_stripped.add(line)
    return domains_stripped

@log_prefix()
def write_unique_line(line, file):
    with open(file, 'r+') as fh:
        if line not in fh:
            fh.write(line)

@log_prefix()
def backup_file_if_exists(file):
    timestamp = str(time.time())
    dest_file = file + '.bak.' + timestamp
    try:
        with open(file, 'r') as sf:
            with open(dest_file, 'x') as df:
                copyfileobj(sf, df)
    except FileNotFoundError:
        pass    # skip backup is file does not exist
            
def validate_domain_list(domains):
    for hostname in domains:
        hostname = hostname.encode('idna').decode('ascii')
        #print(hostname)

def dnsmasq_install_help(output_file):
    dnsmasq_config_line = '\"conf-file=' + output_file + '\"'
    eprint('    $ cp -vi /etc/dnsmasq.conf /etc/dnsmasq.conf.bak.' + str(time.time()))    
    eprint('    $ grep ' + dnsmasq_config_line + ' /etc/dnsmasq.conf || { echo ' \
    + dnsmasq_config_line + ' >> /etc/dnsmasq.conf ; }')
    eprint('    $ /etc/init.d/dnsmasq restart')
    quit(0)

def hosts_install_help(output_file):
    eprint('    $ mv -vi /etc/hosts /etc/hosts.default')
    eprint('    $ cat /etc/hosts.default ' + output_file + ' > /etc/hosts')
    quit(0)

# pylint: disable=invalid-name
output_file_help = '''output file (defaults to ''' + DEFAULT_OUTPUT_FILE + \
' with --mode dnsmasq and stdout with --mode hosts)'
noclobber_help = '''do not overwrite existing output file'''
backup_help = '''backup output file before overwriting'''
install_help_help = '''show commands to configure dnsmasq or /etc/hosts'''
blacklist_help = '''\b
blacklist(s) defaults to:
''' + '\n'.join(['    {0}'.format(i) for i in DEFAULT_BLACKLIST_SOURCES])

whitelist_help = '''\b
whitelists(s) defaults to:''' + DEFAULT_WHITELIST.replace(os.path.expanduser('~'), '~') 
block_at_tld_help = '''
\b
strips subdomains, for example:
    analytics.google.com -> google.com
    Useful for dnsmasq if you are willing to maintain a --whitelist file for inadvertently blocked domains.'''
debug_help = '''print debugging information to stderr'''
show_config_help = '''print config information to stderr'''
cache_help = '''cache --url files as dnsgate_cache_domain_hosts.(timestamp) to ~/.dnsgate/cache'''
dest_ip_help = '''IP to redirect blocked connections to (defaults to 127.0.0.1)'''
restart_dnsmasq_help = '''Restart dnsmasq service (defaults to True, ignored if --mode hosts)'''
blacklist_append_help = '''Add domain to ''' + DEFAULT_BLACKLIST
whitelist_append_help = '''Add domain to ''' + DEFAULT_WHITELIST
# pylint: enable=invalid-name

#https://github.com/mitsuhiko/click/issues/441
CONTEXT_SETTINGS = dict(help_option_names=['--help'], terminal_width=shutil.get_terminal_size((80, 20)).columns) 
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--mode',             is_flag=False, type=click.Choice(['dnsmasq', 'hosts']), default='dnsmasq')
@click.option('--block-at-tld',     is_flag=True,  help=block_at_tld_help)
@click.option('--restart-dnsmasq',  is_flag=True,  help=restart_dnsmasq_help,  default=True)
@click.option('--output-file',      is_flag=False, help=output_file_help,      default=DEFAULT_OUTPUT_FILE)
@click.option('--backup',           is_flag=True,  help=backup_help)
@click.option('--noclobber',        is_flag=True,  help=noclobber_help)
@click.option('--blacklist-append', is_flag=False, help=blacklist_append_help, type=str)
@click.option('--whitelist-append', is_flag=False, help=whitelist_append_help, type=str)
@click.option('--blacklist',        is_flag=False, help=blacklist_help, default=DEFAULT_BLACKLIST_SOURCES)
@click.option('--whitelist',        is_flag=False, help=whitelist_help, default=DEFAULT_WHITELIST_SOURCES)
@click.option('--cache',            is_flag=True,  help=cache_help)
@click.option('--dest-ip',          is_flag=False, help=dest_ip_help)
@click.option('--show-config',      is_flag=True,  help=show_config_help)
@click.option('--install-help',     is_flag=True,  help=install_help_help)
@click.option('--debug',            is_flag=True,  help=debug_help)
@log_prefix()
def main(mode, block_at_tld, restart_dnsmasq, output_file, backup, noclobber, 
            blacklist_append, whitelist_append, blacklist, whitelist, 
            cache, dest_ip, show_config, install_help, debug):

    if show_config:
        print("mode:", mode)
        print("block_at_tld:", block_at_tld)
        print("restart_dnsmasq:", restart_dnsmasq)
        print("output_file:", output_file)
        print("backup:", backup)
        print("noclobber:", noclobber)
        print("blacklist_append:", blacklist_append)
        print("whitelist_append:", whitelist_append)
        print("blacklist:", blacklist)
        print("whitelist:", whitelist)
        print("cache:", cache)
        print("dest_ip:", dest_ip)
        print("debug:", debug)
        print("show_config:", show_config)
        print("install_help:", install_help)
        print("debug:", debug)

    global click_debug
    click_debug = debug
    if debug:
        logger.setLevel(log_levels['DEBUG'])

    if output_file == '-' or output_file == '/dev/stdout':
        output_file = '/dev/stdout'
    else:
        dprint("using non standard output_file")
        output_file = os.path.abspath(output_file)

    if os.path.isfile(output_file) and output_file != '/dev/stdout':
        if noclobber:
            eprint("File '%s' exists. Refusing to overwrite because --noclobber was used. Exiting." % output_file)
            quit(1)

    dprint('output_file:', output_file)

    if install_help:
        if mode == 'dnsmasq':
            dnsmasq_install_help(output_file)
        elif mode == 'hosts':
            hosts_install_help(output_file)

#   idn='☃.net'
    if whitelist_append:
        idn = whitelist_append
        dprint("idn:", idn)
        hostname = idn.encode('idna').decode('ascii')
        dprint("appending hostname:", hostname, "to", DEFAULT_WHITELIST)
        line = hostname + '\n'
        write_unique_line(line, DEFAULT_WHITELIST)

    if blacklist_append:
        idn = blacklist_append
        hostname = idn.encode('idna').decode('ascii')
        dprint("appending hostname:", hostname, "to", DEFAULT_BLACKLIST)
        line = hostname + '\n'
        write_unique_line(line, DEFAULT_BLACKLIST)

    domains_whitelist = set()
    for item in whitelist:
        whitelist_file = os.path.abspath(item)
        domains_whitelist = domains_whitelist|read_list_of_domains(whitelist_file)

    domains_combined_orig = set()   # domains from all sources, combined


    for item in blacklist:
        if item.startswith('http'):
            try:
                logger.debug("trying http:// blacklist location: %s", item)
                domains = get_url(item, cache)
                domains_combined_orig = domains_combined_orig|domains # union
                logger.debug("blacklist: %s", blacklist)
                logger.debug("len(domains_combined_orig): %s", len(domains_combined_orig))

            except Exception as e:
                logger.error("Exception on blacklist url: %s", item)
                logger.exception(e)

        else:
            logger.debug("trying local blacklist file: %s", item)
            blacklist_file = os.path.abspath(item)
            domains = read_list_of_domains(blacklist_file)
            logger.debug("got %s domains from %s", domains, blacklist_file)
            if domains:
                domains_combined_orig = domains_combined_orig|domains # union
#           import IPython; IPython.embed()
    
    

    domains_combined_orig = domains_combined_orig - domains_whitelist  # remove exact whitelist matches

    if DEFAULT_BLACKLIST in blacklist:
        logger.debug("re adding items from local blacklist file: %s", )
        blacklist_file = os.path.abspath(DEFAULT_BLACKLIST)
        domains = read_list_of_domains(blacklist_file)
        logger.debug("got %s domains from %s", domains, blacklist_file)
        if domains:
            domains_combined_orig = domains_combined_orig|domains # union



    validate_domain_list(domains_combined_orig)

    


    domains_combined = copy.deepcopy(domains_combined_orig)

    if block_at_tld:
        domains_combined = strip_to_tld(domains_combined)

#   import IPython; IPython.embed()

    # re-add subdomains of whitelisted domains
    #re-add subdomains that are not explicitly whitelisted or already blocked by another rule
    for orig_domain in domains_combined_orig:
        if orig_domain not in domains_whitelist:
            if orig_domain not in domains_combined:
                orig_domain_tldextract = domain_extract(orig_domain)
                orig_domain_tld = orig_domain_tldextract.domain + '.' + orig_domain_tldextract.suffix
                if orig_domain_tld not in domains_combined:
                    dprint("re-adding:", orig_domain)
                    domains_combined.add(orig_domain)

    domains_combined = group_by_tld(domains_combined)

    if backup:
        backup_file_if_exists(output_file)

    try:
        os.mkdir(CONFIG_DIRECTORY)
    except FileExistsError:
        pass

    if mode == 'hosts':
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                if dest_ip:
                    hosts_line = dest_ip + ' ' + domain + '\n'
                else:
                    hosts_line = '127.0.0.1' + ' ' + domain + '\n'
                fh.write(hosts_line)

    elif mode == 'dnsmasq':
        with open(output_file, 'w') as fh:
            for domain in domains_combined:
                if dest_ip:
                    dnsmasq_line = 'address=/.' + domain + '/' + dest_ip + '\n'
                else:
                    dnsmasq_line = 'server=/.' + domain + '/' '\n'  #return NXDOMAIN
                fh.write(dnsmasq_line)
    else:
        print("unknown mode:", mode)
        quit(1)

    if restart_dnsmasq:
        if mode != 'hosts':
            restart_dnsmasq_service()


if __name__ == '__main__':
    no_cache_extract = tldextract.TLDExtract(cache_file=False)
    main()
    dprint("Exiting without error.")
    quit(0)
